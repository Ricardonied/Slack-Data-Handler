#instalar pacotes necessários para o procedimento de exportação do histórico de conversas do slack
install.packages("rjson")
library(rjson) #import and manipulate JSON files
install.packages("dplyr")
library(dplyr) #data handling / pipe char

#Descompacte o arquivo de exportação do Slack
#Colocar a pasta descompactada exportada no slack no diretório do R C:\Users\Usuário\Documents
#getwd() <- "C:/Users/Usuário/Documents"
#Copiar o nome da pasta descompactada, e mudar o nome da variável exportname 
#exportname <- "exportunzipped"
exportname <- "Intelbras-WiseFi Slack export Jul 1 2023 - Sep 30 2023"
working_directory <- getwd() %>% as.character()
slackexport_folder_path <- paste0(working_directory,"/",exportname)

#Faça uma lista de todos os canais presentes no slack export
#Essas informações estão todas no arquivo "<path>/exportname/channels.json".
channels_path <- paste0(slackexport_folder_path,"/channels.json")
channels_json <- fromJSON(file = channels_path)
channel_list <- setNames(data.frame(matrix(ncol = 9, nrow = 0)), 
                         c("ch_id", "name", "created", "creator", "is_archived",
                           "is_general", "members", "topic", "purpose"))

for (channel in 1:length(channels_json)) { 
  #Make a df (channel_list) with information about each channel, from the JSON file
  channel_list[channel, "ch_id"] <- channels_json[[channel]]$id
  channel_list[channel, "name"] <- channels_json[[channel]]$name
  channel_list[channel, "created"] <- channels_json[[channel]]$created
  channel_list[channel, "creator"] <- channels_json[[channel]]$creator
  channel_list[channel, "is_archived"] <- channels_json[[channel]]$is_archived
  channel_list[channel, "is_general"] <- channels_json[[channel]]$is_general
  
  #make a comma separated list of members
  memberlist <- ""
  if (length(channels_json[[channel]]$members) > 0) { # Verifica se a lista de membros não está vazia
    for (member in 1:length(channels_json[[channel]]$members)) {
      #if it isn't the last member
      if (member < length(channels_json[[channel]]$members)) {
        memberlist <- paste0(memberlist, channels_json[[channel]]$members[[member]], ", ")
      }
      if (member == length(channels_json[[channel]]$members)) {
        memberlist <- paste0(memberlist, channels_json[[channel]]$members[[member]])
      }
    }
  }
  channel_list[channel, "members"] <- memberlist
  channel_list[channel, "topic"] <- channels_json[[channel]]$topic$value
  channel_list[channel, "purpose"] <- channels_json[[channel]]$purpose$value
  
  #For each channel make a list of all the individual JSON files (one file per day of activity)
  #Add that list to the channels_json object as a list in each channel: channels_json[[channel]]$dayslist
  channel_folder_path <- ""
  channels_json[[channel]]$dayslist <- ""
  channel_folder_path <- paste0(slackexport_folder_path,"/",channel_list[channel,"name"])
  channels_json[[channel]]$dayslist <- list.files(channel_folder_path, 
                                                  pattern=NULL, all.files=FALSE, full.names=FALSE)
}

# Função para converter um único arquivo JSON em um dataframe com campos específicos extraídos
slack_json_to_dataframe <- function(slack_json) {
  # Inicializa o dataframe com as colunas esperadas
  messages_df <- setNames(data.frame(matrix(ncol = 10, nrow = 0)), 
                          c("msg_id", "ts", "user", "type", "text", "reply_count",
                            "reply_users_count", "ts_latest_reply", "ts_thread", 
                            "parent_user_id"))
  
  # Itera sobre cada mensagem no arquivo JSON
  for (message in 1:length(slack_json)) {
    # Atribui os valores, substituindo `NULL` por `NA` para evitar erros
    msg_id <- if (!is.null(slack_json[[message]]$client_msg_id)) slack_json[[message]]$client_msg_id else NA
    ts <- if (!is.null(slack_json[[message]]$ts)) slack_json[[message]]$ts else NA
    user <- if (!is.null(slack_json[[message]]$user)) slack_json[[message]]$user else NA
    type <- if (!is.null(slack_json[[message]]$type)) slack_json[[message]]$type else NA
    text <- if (!is.null(slack_json[[message]]$text)) slack_json[[message]]$text else NA
    reply_count <- if (!is.null(slack_json[[message]]$reply_count)) slack_json[[message]]$reply_count else NA
    reply_users_count <- if (!is.null(slack_json[[message]]$reply_users_count)) slack_json[[message]]$reply_users_count else NA
    ts_latest_reply <- if (!is.null(slack_json[[message]]$latest_reply)) slack_json[[message]]$latest_reply else NA
    ts_thread <- if (!is.null(slack_json[[message]]$thread_ts)) slack_json[[message]]$thread_ts else NA
    parent_user_id <- if (!is.null(slack_json[[message]]$parent_user_id)) slack_json[[message]]$parent_user_id else NA
    
    # Adiciona a mensagem ao dataframe
    messages_df <- rbind(messages_df, data.frame(
      msg_id = msg_id, 
      ts = ts, 
      user = user, 
      type = type, 
      text = text, 
      reply_count = reply_count, 
      reply_users_count = reply_users_count, 
      ts_latest_reply = ts_latest_reply, 
      ts_thread = ts_thread, 
      parent_user_id = parent_user_id,
      stringsAsFactors = FALSE
    ))
  }
  
  return(messages_df)
}

# Inicializa o dataframe final para armazenar todas as mensagens de todos os canais
all_channels_all_files_df <- setNames(data.frame(matrix(ncol = 11, nrow = 0)), 
                                      c("msg_id", "ts", "user", "type", "text",
                                        "reply_count", "reply_users_count", 
                                        "ts_latest_reply", "ts_thread", "parent_user_id",
                                        "channel"))

# Loop para processar cada canal
for (channel in 1:length(channels_json)) {
  # Inicializa o dataframe para todas as mensagens em um único canal
  all_channel_files_df <- setNames(data.frame(matrix(ncol = 10, nrow = 0)), 
                                   c("msg_id", "ts", "user", "type", "text",
                                     "reply_count", "reply_users_count", 
                                     "ts_latest_reply", "ts_thread", "parent_user_id"))
  
  # Verifica se a lista 'dayslist' não está vazia
  if (length(channels_json[[channel]]$dayslist) > 0) {
    for (file_day in 1:length(channels_json[[channel]]$dayslist)) {
      # Importa o arquivo JSON para um dia específico
      parentfolder_path <- paste0(slackexport_folder_path,"/",channels_json[[channel]]$name)
      filejson_path <- paste0(parentfolder_path, "/", channels_json[[channel]]$dayslist[[file_day]])
      import_file_json <- fromJSON(file = filejson_path)
      
      # Converte o arquivo JSON para um dataframe usando a função `slack_json_to_dataframe`
      import_file_df <- slack_json_to_dataframe(import_file_json)
      
      # Adiciona os dados do dia ao dataframe de todas as mensagens do canal
      all_channel_files_df <- rbind(all_channel_files_df, import_file_df)
    }
    
    # Adiciona o nome do canal ao dataframe
    all_channel_files_df$channel <- channels_json[[channel]]$name
    
    # Adiciona os dados do canal ao dataframe final com todas as mensagens de todos os canais
    all_channels_all_files_df <- rbind(all_channels_all_files_df, all_channel_files_df)
  } else {
    # Se a lista 'dayslist' estiver vazia, emite um aviso (opcional)
    warning(paste("O canal", channels_json[[channel]]$name, "não tem arquivos JSON associados."))
  }
}



#write the all files to a CSV in your R working directory
#format: exportfoldername_mindate_to_maxdate.csv
filename_mindate <- min(all_channels_all_files_df$ts) %>% as.numeric() %>% as.Date.POSIXct()
filename_maxdate <- max(all_channels_all_files_df$ts) %>% as.numeric() %>% as.Date.POSIXct()
#Note exportfoldername was defined earlier before pulling in any of the files: exportname
slack_export_df_filename <- paste0(exportname,"_",filename_mindate,"_to_",filename_maxdate,".csv")
write.csv(all_channels_all_files_df, file = slack_export_df_filename)

#TODO - how does it handle orphaned threads? or deleted children? 
#TODO - make a users table with user metadata, write to csv
users_path <- paste0(slackexport_folder_path,"/users.json")
users_json <- fromJSON(file = users_path)
#initialize empty user df
user_list_df <- setNames(data.frame(matrix(ncol = 11, nrow = 0)), 
                         c("user_id", "team_id", "name", "deleted", "real_name",
                           "tz", "tz_label", "tz_offset", "title", "display_name", 
                           "is_bot"))
#fill it with the appropriate fields from JSON
for (user in 1:length(users_json)) {
  user_list_df[user, "user_id"] <- users_json[[user]]$id
  user_list_df[user, "team_id"] <- users_json[[user]]$team_id
  user_list_df[user, "name"] <- users_json[[user]]$name
  user_list_df[user, "deleted"] <- users_json[[user]]$deleted
  #real_name is in a different place for bots - its nested in $profile
  if (is.null(users_json[[user]]$real_name) == FALSE) {
    user_list_df[user, "real_name"] <- users_json[[user]]$real_name
  }
  if (is.null(users_json[[user]]$profile$real_name) == FALSE) {
    user_list_df[user, "real_name"] <- users_json[[user]]$profile$real_name
  }
  user_list_df[user, "title"] <- users_json[[user]]$profile$title
  user_list_df[user, "display_name"] <- users_json[[user]]$profile$display_name
  user_list_df[user, "is_bot"] <- users_json[[user]]$is_bot
  #bots (?not sure who else) don't have time zone information. catch that null
  if (is.null(users_json[[user]]$tz) == FALSE) {
    user_list_df[user, "tz"] <- users_json[[user]]$tz
    user_list_df[user, "tz_label"] <- users_json[[user]]$tz_label
    user_list_df[user, "tz_offset"] <- users_json[[user]]$tz_offset
  }
  
}
#write user data to a csv to be read back in as df, as needed.
slack_export_user_filename <- paste0(exportname,"_users.csv")
write.csv(user_list_df, file = slack_export_user_filename)


#Write a csv for channel metadata
#write user data to a csv to be read back in as df, as needed.
slack_export_channel_filename <- paste0(exportname,"_channels.csv")
write.csv(channel_list, file = slack_export_channel_filename)

